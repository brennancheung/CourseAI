'use client'

import { useRef, useEffect, useState, useCallback } from 'react'
import abcjs from 'abcjs'
import type { NoteMapTrack } from 'abcjs'

type DebugScorePlayerProps = {
  abc: string
  initialTempo?: number
}

/**
 * Debug version of ScorePlayer that displays the actual note sequence
 * generated by the synth's sequenceCallback.
 *
 * IMPORTANT: Timing values from sequenceCallback are in MEASURES, not seconds.
 * For example, at 60 BPM in 4/4 time:
 *   - start=0.000 → 0 seconds
 *   - start=1.000 → 4 seconds (1 measure = 4 beats = 4 seconds)
 *   - dur=1.000 → 4 seconds duration
 *
 * See: docs/abcjs-synth-behavior.md for full documentation
 */
export function DebugScorePlayer({ abc, initialTempo = 60 }: DebugScorePlayerProps) {
  const containerRef = useRef<HTMLDivElement>(null)
  const synthRef = useRef<abcjs.MidiBuffer | null>(null)
  const [isPlaying, setIsPlaying] = useState(false)
  const [noteSequence, setNoteSequence] = useState<NoteMapTrack[] | null>(null)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const container = containerRef.current
    if (!container) return

    let mounted = true

    const init = async () => {
      try {
        // Render the ABC notation
        const visualObjs = abcjs.renderAbc(container, abc, {
          responsive: 'resize',
          add_classes: true,
          paddingtop: 10,
          paddingbottom: 10,
        })

        if (!mounted || !visualObjs?.length) return

        // Create synth with sequenceCallback to capture notes
        const synth = new abcjs.synth.CreateSynth()
        synthRef.current = synth

        await synth.init({
          visualObj: visualObjs[0],
          options: {
            qpm: initialTempo,
            chordsOff: true, // Disable auto-accompaniment from chord symbols
            // This callback intercepts the note sequence before playback
            sequenceCallback: (sequence: NoteMapTrack[]) => {
              console.log('=== ABCJS Note Sequence ===')
              console.log('Full sequence:', sequence)

              // Log each track
              sequence.forEach((track, trackIndex) => {
                console.log(`Track ${trackIndex}:`, track)
                track.forEach((note, noteIndex) => {
                  console.log(`  Note ${noteIndex}:`, {
                    pitch: note.pitch,
                    instrument: note.instrument,
                    start: note.start,
                    end: note.end,
                    duration: note.end - note.start,
                    volume: note.volume,
                  })
                })
              })

              if (mounted) {
                setNoteSequence(sequence)
              }

              // Return the sequence unchanged
              return sequence
            },
          },
        })
      } catch (err) {
        if (mounted) {
          setError(err instanceof Error ? err.message : 'Unknown error')
        }
      }
    }

    init()

    return () => {
      mounted = false
      synthRef.current?.stop()
    }
  }, [abc, initialTempo])

  const togglePlay = useCallback(async () => {
    const synth = synthRef.current
    if (!synth) return

    if (isPlaying) {
      synth.stop()
      setIsPlaying(false)
    } else {
      await synth.prime()
      synth.start()
      setIsPlaying(true)
    }
  }, [isPlaying])

  // Format note sequence for display
  const formatSequence = () => {
    if (!noteSequence) return 'Loading...'

    const allNotes: Array<{
      start: number
      end: number
      pitch: number
      instrument: string
    }> = []

    noteSequence.forEach((track) => {
      track.forEach((note) => {
        allNotes.push({
          start: note.start,
          end: note.end,
          pitch: note.pitch,
          instrument: note.instrument,
        })
      })
    })

    // Sort by start time
    allNotes.sort((a, b) => a.start - b.start)

    // Group by start time (using raw value, rounded to 3 decimals for grouping)
    const grouped: Record<string, typeof allNotes> = {}
    allNotes.forEach((note) => {
      const startKey = note.start.toFixed(3)
      if (!grouped[startKey]) grouped[startKey] = []
      grouped[startKey].push(note)
    })

    return Object.entries(grouped)
      .sort(([a], [b]) => Number(a) - Number(b))
      .map(([startRaw, notes]) => {
        const duration = notes[0].end - notes[0].start
        const pitches = notes.map((n) => n.pitch).join(', ')
        return `start=${startRaw}, end=${notes[0].end.toFixed(3)}, dur=${duration.toFixed(3)} | pitches: ${pitches}`
      })
      .join('\n')
  }

  return (
    <div className="space-y-4">
      {/* Score display */}
      <div
        ref={containerRef}
        className="rounded-lg p-4 border overflow-x-auto"
        style={{ backgroundColor: 'white', colorScheme: 'light', color: 'black' }}
      />

      {error && <div className="text-red-500 text-sm">{error}</div>}

      {/* Controls */}
      <button
        type="button"
        onClick={togglePlay}
        className="px-4 py-2 bg-primary text-primary-foreground rounded"
      >
        {isPlaying ? 'Stop' : 'Play'}
      </button>

      {/* Note sequence display */}
      <div className="space-y-2">
        <h3 className="font-semibold text-sm">Synth Note Sequence (from sequenceCallback):</h3>
        <pre className="text-xs bg-muted p-3 rounded overflow-x-auto max-h-64 overflow-y-auto">
          {formatSequence()}
        </pre>
        <p className="text-xs text-muted-foreground">
          This shows when each note starts (in ms) and its duration.
          At 60 BPM, a quarter note = 1000ms, whole note = 4000ms.
        </p>
      </div>
    </div>
  )
}
